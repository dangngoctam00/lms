// Code generated by enthistory, DO NOT EDIT.
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"time"

	"lms-class/ent/examhistory"
	"lms-class/ent/questionhistory"

	"github.com/flume/enthistory"
)

type Change struct {
	FieldName string
	Old       any
	New       any
}

func NewChange(fieldName string, old, new any) Change {
	return Change{
		FieldName: fieldName,
		Old:       old,
		New:       new,
	}
}

type HistoryDiff[T any] struct {
	Old     *T
	New     *T
	Changes []Change
}

var (
	MismatchedRefError    = errors.New("cannot take diff of histories with different Refs")
	IdenticalHistoryError = errors.New("cannot take diff of identical history")
)

func (eh *ExamHistory) changes(new *ExamHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(eh.Title, new.Title) {
		changes = append(changes, NewChange(examhistory.FieldTitle, eh.Title, new.Title))
	}
	if !reflect.DeepEqual(eh.Context, new.Context) {
		changes = append(changes, NewChange(examhistory.FieldContext, eh.Context, new.Context))
	}
	if !reflect.DeepEqual(eh.ContextId, new.ContextId) {
		changes = append(changes, NewChange(examhistory.FieldContextId, eh.ContextId, new.ContextId))
	}
	if !reflect.DeepEqual(eh.IsPublished, new.IsPublished) {
		changes = append(changes, NewChange(examhistory.FieldIsPublished, eh.IsPublished, new.IsPublished))
	}
	if !reflect.DeepEqual(eh.HavingDraft, new.HavingDraft) {
		changes = append(changes, NewChange(examhistory.FieldHavingDraft, eh.HavingDraft, new.HavingDraft))
	}
	if !reflect.DeepEqual(eh.LastPublishedAt, new.LastPublishedAt) {
		changes = append(changes, NewChange(examhistory.FieldLastPublishedAt, eh.LastPublishedAt, new.LastPublishedAt))
	}
	if !reflect.DeepEqual(eh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(examhistory.FieldUpdatedAt, eh.UpdatedAt, new.UpdatedAt))
	}
	return changes
}

func (eh *ExamHistory) Diff(history *ExamHistory) (*HistoryDiff[ExamHistory], error) {
	if eh.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	ehUnix, historyUnix := eh.HistoryTime.Unix(), history.HistoryTime.Unix()
	ehOlder := ehUnix < historyUnix || (ehUnix == historyUnix && eh.ID < history.ID)
	historyOlder := ehUnix > historyUnix || (ehUnix == historyUnix && eh.ID > history.ID)

	if ehOlder {
		return &HistoryDiff[ExamHistory]{
			Old:     eh,
			New:     history,
			Changes: eh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ExamHistory]{
			Old:     history,
			New:     eh,
			Changes: history.changes(eh),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (qh *QuestionHistory) changes(new *QuestionHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(qh.Context, new.Context) {
		changes = append(changes, NewChange(questionhistory.FieldContext, qh.Context, new.Context))
	}
	if !reflect.DeepEqual(qh.ContextId, new.ContextId) {
		changes = append(changes, NewChange(questionhistory.FieldContextId, qh.ContextId, new.ContextId))
	}
	if !reflect.DeepEqual(qh.Position, new.Position) {
		changes = append(changes, NewChange(questionhistory.FieldPosition, qh.Position, new.Position))
	}
	if !reflect.DeepEqual(qh.QuestionType, new.QuestionType) {
		changes = append(changes, NewChange(questionhistory.FieldQuestionType, qh.QuestionType, new.QuestionType))
	}
	if !reflect.DeepEqual(qh.Data, new.Data) {
		changes = append(changes, NewChange(questionhistory.FieldData, qh.Data, new.Data))
	}
	if !reflect.DeepEqual(qh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(questionhistory.FieldUpdatedAt, qh.UpdatedAt, new.UpdatedAt))
	}
	return changes
}

func (qh *QuestionHistory) Diff(history *QuestionHistory) (*HistoryDiff[QuestionHistory], error) {
	if qh.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	qhUnix, historyUnix := qh.HistoryTime.Unix(), history.HistoryTime.Unix()
	qhOlder := qhUnix < historyUnix || (qhUnix == historyUnix && qh.ID < history.ID)
	historyOlder := qhUnix > historyUnix || (qhUnix == historyUnix && qh.ID > history.ID)

	if qhOlder {
		return &HistoryDiff[QuestionHistory]{
			Old:     qh,
			New:     history,
			Changes: qh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[QuestionHistory]{
			Old:     history,
			New:     qh,
			Changes: history.changes(qh),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (c Change) String(op enthistory.OpType) string {
	var newstr, oldstr string
	if c.New != nil {
		val, err := json.Marshal(c.New)
		if err != nil {
			newstr = fmt.Sprintf("%#v", c.New)
		} else {
			newstr = string(val)
		}
	}
	if c.Old != nil {
		val, err := json.Marshal(c.Old)
		if err != nil {
			oldstr = fmt.Sprintf("%#v", c.Old)
		} else {
			oldstr = string(val)
		}
	}
	switch op {
	case enthistory.OpTypeInsert:
		return fmt.Sprintf("%s: %#s", c.FieldName, newstr)
	case enthistory.OpTypeDelete:
		return fmt.Sprintf("%s: %#s", c.FieldName, oldstr)
	default:
		return fmt.Sprintf("%s: %#s -> %#s", c.FieldName, oldstr, newstr)
	}
}

func (c *Client) Audit(ctx context.Context) ([][]string, error) {
	records := [][]string{
		{"Table", "Ref Id", "History Time", "Operation", "Changes", "Updated By"},
	}
	var record [][]string
	var err error
	record, err = auditExamHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	record, err = auditQuestionHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	return records, nil
}

type record struct {
	Table       string
	RefId       any
	HistoryTime time.Time
	Operation   enthistory.OpType
	Changes     []Change
	UpdatedBy   *int
}

func (r *record) toRow() []string {
	row := make([]string, 6)

	row[0] = r.Table
	row[1] = fmt.Sprintf("%v", r.RefId)
	row[2] = r.HistoryTime.Format(time.ANSIC)
	row[3] = r.Operation.String()
	for i, change := range r.Changes {
		if i == 0 {
			row[4] = change.String(r.Operation)
			continue
		}
		row[4] = fmt.Sprintf("%s\n%s", row[4], change.String(r.Operation))
	}
	if r.UpdatedBy != nil {
		row[5] = fmt.Sprintf("%v", *r.UpdatedBy)
	}
	return row
}

type examhistoryref struct {
	Ref int
}

func auditExamHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []examhistoryref
	client := NewExamHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(examhistory.ByRef()).
		Select(examhistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(examhistory.Ref(currRef.Ref)).
			Order(examhistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "ExamHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
				UpdatedBy:   curr.UpdatedBy,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&ExamHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&ExamHistory{})
			default:
				if i == 0 {
					record.Changes = (&ExamHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

type questionhistoryref struct {
	Ref int
}

func auditQuestionHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []questionhistoryref
	client := NewQuestionHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(questionhistory.ByRef()).
		Select(questionhistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(questionhistory.Ref(currRef.Ref)).
			Order(questionhistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "QuestionHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
				UpdatedBy:   curr.UpdatedBy,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&QuestionHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&QuestionHistory{})
			default:
				if i == 0 {
					record.Changes = (&QuestionHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}
